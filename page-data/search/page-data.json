{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"SOLID 디자인 원칙 SOLID는 객체 지향 프로그래밍과 소프트웨어 디자인 원칙을 나타내는 다섯 가지 기본 원칙의 앞글자를 모아놓은 말로, 소프트웨어 아키텍처의 유연성, 확장성, 유지보수성을 향상시키기 위한 가이드라인을 제시한다. SOLID 원칙은 소프트웨어의 품질을 높이기 위한 중요한 개념들을 포함하고 있다. SRP(Single Responsibili…","fields":{"slug":"/solid/"},"frontmatter":{"date":"August 17, 2023","title":"객체지향 디자인 원칙(SOLID)","tags":["OOP, SOLID"]},"rawMarkdownBody":"\n## SOLID 디자인 원칙\n\nSOLID는 객체 지향 프로그래밍과 소프트웨어 디자인 원칙을 나타내는 다섯 가지 기본 원칙의 앞글자를 모아놓은 말로, 소프트웨어 아키텍처의 유연성, 확장성, 유지보수성을 향상시키기 위한 가이드라인을 제시한다. SOLID 원칙은 소프트웨어의 품질을 높이기 위한 중요한 개념들을 포함하고 있다.\n\n### SRP(Single Responsibility Principle): 단일 책임 원칙\n\n* 하나의 클래스는 하나의 책임만 가져야 한다.\n* 클래스가 변경되어야 하는 이유는 오직 하나여야 한다.\n* 클래스가 너무 많은 책임을 갖게 되면 변경 사항에 대한 영향이 많아지고 유지보수가 어려워진다.\n\n### OCP(Open-Closed Principle): 개방-폐쇄 원칙\n\n* 소프트웨어 개체(클래스, 모듈 등)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.\n* 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있도록 설계해야 한다.\n\n### LSP(Liskov Substitution Principle): 리스코프 치환 원칙\n\n* 하위 클래스는 언제나 기본 클래스로 대체 가능해야 한다.\n* 상속 관계에서 하위 클래스는 상위 클래스의 기능을 유지하면서 추가적인 기능을 확장해야 한다.\n\n### ISP(Interface Segregation Principle): 인터페이스 분리 원칙\n\n* 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하도록 강요하지 말아야 한다.\n* 클라이언트는 필요한 메서드만 있는 인터페이스를 갖게 되어야 한다.\n* 성격이 다른 경우 인터페이스를 분리하여 의존성을 높이지 않도록 한다.\n\n### DIP(Dependency Inversion Principle): - 의존성 역전 원칙\n\n* 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 모두 추상화된 내용에 의존해야 한다.\n* 추상화된 내용은 구체적인 내용에 의존해서는 안된다.\n"},{"excerpt":"State Pattern","fields":{"slug":"/state-pattern/"},"frontmatter":{"date":"August 16, 2023","title":"State Pattern을 선택하는 이유","tags":["GoF, Design Pattern"]},"rawMarkdownBody":"\n## State Pattern\n"},{"excerpt":"Policy Pattern","fields":{"slug":"/policy-pattern/"},"frontmatter":{"date":"August 16, 2023","title":"Policy Pattern","tags":["GoF, Design Pattern"]},"rawMarkdownBody":"\n## Policy Pattern\n"},{"excerpt":"Conceptual Modeling 복잡한 시스템이나 현상을 이해하기 위해 개념적으로 추상화된 모델을 생성하는 프로세스. 이 모델은 현실 세계의 요소와 그들 간의 관계를 나타내고, 이를 단순화하여 이해하기 쉽도록 돕는 도구이다. Conceptual Modeling 목적 이해와 의사소통 요구사항 정의 분석 및 설계 복잡성 관리 Conceptual Model…","fields":{"slug":"/conceptual-design-modeling/"},"frontmatter":{"date":"August 16, 2023","title":"Modeling에 대하여","tags":["oop"]},"rawMarkdownBody":"\n## Conceptual Modeling\n\n복잡한 시스템이나 현상을 이해하기 위해 개념적으로 추상화된 모델을 생성하는 프로세스. 이 모델은 현실 세계의 요소와 그들 간의 관계를 나타내고, 이를 단순화하여 이해하기 쉽도록 돕는 도구이다.\n\n### Conceptual Modeling 목적\n\n1. 이해와 의사소통\n2. 요구사항 정의\n3. 분석 및 설계\n4. 복잡성 관리\n\n### Conceptual Modeling 요소\n\n1. 엔터티(Entity)와 속성(Attribute)\n   * 현실 세계의 객체나 개념을 나타내는 엔터티와 그 엔터티의 특성을 나타내는 속성을 정의.\n2. 관계(Relationship)\n   * 엔터티들 간의 관계를 정의하여 시스템 내부의 상호 작용을 모델링.\n3. 클래스(Class)와 객체(Object)\n   * 객체 지향적 접근에서 클래스는 유사한 특성과 동작을 가진 엔터티의 집합을 나타내며, 객체는 실제로 존재하는 클래스의 인스턴스를 나타낸다.\n4. 다이어그램(Diagram)\n   * Conceptual Modeling을 시각적으로 나타내는 도구로, UML(Unified Modeling Language) 다이어그램과 같은 것들이 사용된다.\n5. 표준 모델링 언어\n   * 시스템을 모델링하는 데 사용되는 표준 언어로는 UML, ER(Entity-Relationship) 다이어그램, BPMN(Business Process Model and Notation) 등이 있다.\n6. 모델링 도구\n   * 컴퓨터 소프트웨어를 사용하여 Conceptual Modeling을 수행할 수 있는 도구와 소프트웨어가 있다.\n\nConceptual Modeling은 시스템 설계와 구축의 초기 단계에서 중요한 역할을 한다. 이를 통해 요구사항이 명확하게 정의되고, 모든 관계자들이 공통된 이해를 갖게 되어 프로젝트의 성공 확률을 높일 수 있다.\n\n## Design Modeling\n\n시스템이나 제품의 실제 구조와 동작을 세부적으로 설계하고 나타내는 프로세스이다. 이 단계에서는 Conceptual Modeling에서 정의한 개념들을 구체적인 구성 요소와 상호 작용으로 변환하여 시스템의 실제 동작 방식을 묘사한다. Design Modeling은 주로 소프트웨어 개발 및 공학 분야에서 활용되며, 시스템 설계의 중요한 부분을 이룬다.\n\n### Design Modeling 목적\n\n1. 시스템 구조 설계\n   * 시스템의 구성 요소, 모듈, 클래스 등을 정의하고 그들 간의 관계와 상호 작용을 설계.\n2. 동작 설계\n   * 시스템이 어떻게 동작할지를 정의하고, 각 상황에 따른 동작 흐름과 프로세스를 모델링.\n3. 인터페이스 설계\n   * 시스템의 내부 구성 요소와 외부 요소(사용자, 다른 시스템 등) 간의 인터페이스를 설계하여 상호 작용을 관리.\n4. 데이터 구조 설계\n   * 데이터베이스의 테이블, 필드, 관계 등을 설계하고 데이터의 흐름과 저장 방식을 정의.\n5. 시스템 최적화\n   * 성능, 확장성, 유지보수성 등을 고려하여 시스템을 최적화하는 설계를 수행.\n\n### Design Modeling 방법\n\n1. UML 다이어그램\n   * Unified Modeling Language(UML)은 객체 지향 소프트웨어 설계를 위한 표준 언어\n   * 다양한 다이어그램(클래스 다이어그램, 시퀀스 다이어그램, 상태 다이어그램 등)을 사용하여 시스템의 다양한 측면을 모델링.\n2. 데이터베이스 모델링\n   * 데이터베이스 시스템을 설계할 때 엔터티, 속성, 관계 등을 모델링하여 데이터의 구조와 저장 방식을 결정.\n3. 워크플로우 및 프로세스 모델링\n   * 비즈니스 프로세스나 워크플로우를 모델링하여 효율적인 작업 흐름을 설계.\n4. 아키텍처 설계\n   * 시스템의 전체적인 아키텍처를 설계하여 컴포넌트, 계층 구조, 통신 방식 등을 결정.\n\nDesign Modeling은 시스템의 구체적인 세부 사항을 정의함으로써 개발자들이 일관된 방식으로 작업하고, 시스템의 설계 결정 사항을 명확히 이해할 수 있도록 한다. 이는 소프트웨어나 제품의 개발 프로세스에서 효율성과 품질을 높이는데 기여한다.\n"},{"excerpt":"Message Oriented Programming MOP: Message Oriented Programming 다양한 컴포넌트나 모듈이 서로 메시지를 주고받아 상호 작용하는 프로그래밍 패러다임.\n컴포넌트 간의 결합도를 낮추고 모듈화를 촉진하여 더 유연하고 확장 가능한 소프트웨어를 구축할 수 있다. 메시지 기반 또는 주도 프로그래밍이란 용어보다는 메시지 …","fields":{"slug":"/message-driven-development/"},"frontmatter":{"date":"July 22, 2023","title":"메시지 지향 프로그래밍","tags":["oop"]},"rawMarkdownBody":"\n## Message Oriented Programming\n\nMOP: Message Oriented Programming\n\n다양한 컴포넌트나 모듈이 서로 메시지를 주고받아 상호 작용하는 프로그래밍 패러다임.\n컴포넌트 간의 결합도를 낮추고 모듈화를 촉진하여 더 유연하고 확장 가능한 소프트웨어를 구축할 수 있다.\n\n메시지 기반 또는 주도 프로그래밍이란 용어보다는 메시지 지향 프로그래밍이라는 용어를 더 많이 사용하는 듯 하다.\n\n객체가 서로를 직접 호출하지 않고 메시지 버스를 통해 통신해야 한다는 특징을 가지고 있다.\n\n## 주요 특징 및 개념\n\n1. 메시지\n   * 컴포넌트 간의 통신은 메시지를 통해 이루어진다.\n   * 메시지는 sender가 보낸 메시지를 이벤트 버스를 통해 구독 중인 receiver로 전달된다.\n2. 비동기 통신\n   * 메시지 지향 프로그래밍은 비동기 통신이 일반적이다.\n   * sender가 즉시 결과를 기다리지 않고 작업을 계속할 수 있도록 한다.\n   * receiver는 메시지를 받아 작업을 처리하고 응답을 보낼 수 있다.\n3. 이벤트 주도\n   * 메시지는 이벤트를 트리거하거나 처리하는 데 사용된다.\n4. 모듈화와 결합도 감소\n   * 각 컴포넌트가 독립적으로 작동하며, 메시지를 통해 상호 작용하므로 모듈화가 용이하다.\n5. 분산 시스템\n   * 분산 시스템에서 유용하게 활용된다.\n   * 여러 컴포넌트나 서버가 네트워크를 통해 메시지를 주고받아 작업을 처리하고 결과를 공유할 수 있다.\n\n## 장점\n\n1. 발신자와 응답자 사이의 결합 제거\n   * 객체가 서로를 직접 참조하지 않기 때문에 Code Refactoring 하는 경우에 작업이 원활하다.\n2. 종속성 즉시 변경\n   * 객체는 상황에 따라 메시지 구독하거나 취소할 수 있기 때문에 동작을 동적으로 변경할 수 있다.\n3. 여러 구독자에게 발송\n   * 여러 객체가 동일한 유형의 메시지를 동시에 수신 대기할 수 있다. 시스템의 여러 부분을 업데이트 해야하는 이벤트가 발생할 때 개별적으로 알리지 않아도 된다.\n\n## 단점\n\n1. 메모리 및 처리 오버헤드\n   * 메시지 전송에는 메시지 내 전달되는 데이터의 크기에 따라 메모리 및 처리 비용이 수반된다.\n   * 메시지 통신하는 객체는 캡슐화된 상태를 공유해서는 안되기 때문에 메시지 데이터가 구독 객체에 의해 수정될 경우 데이터를 복사해서 사용해야 한다.\n2. 과도한 메시지 유형의 증가\n   * 객체는 여러 가지 방법으로 서로 통신하기 때문에 필요한 메시지 유형의 수가 과도하게 증가할 수 있다.\n   * 구현 방법에 관계없이 메시지 유형의 수가 많아질 수 있기 때문에 신중한 관리가 필요하다.\n3. 흐름을 추론하기 어려움\n   * 동적 특성으로 인해 정확한 흐름을 파악하는 것이 어려울 수 있다.\n   * 그로 인해 디버깅 또한 까다로워진다.\n\n## 이벤트 주도 프로그래밍과의 차이\n\n이벤트 주도 프로그래밍은 주로 이벤트를 중심으로 동작하며, 이벤트가 발생할 때 특정 동작을 수행한다. 이에 반해 메시지 지향 프로그래밍은 메시지를 주고받아 컴포넌트 간의 상호 작용을 관리하고 모듈화하는 데 중점을 둔다. 이벤트 주도 프로그래밍은 주로 사용자 입력이나 시스템 상태 변화에 응답하는 데 사용되고, 메시지 지향 프로그래밍은 컴포넌트 간의 통신과 모듈화에 사용된다.\n\n## Actor Model (행위자 모델)\n\nActor Model은 Actor를 병행 연산(Concurrent Computing)의 범용적 기본 단위로 삼는 모델이다.\n\nActor Model에서 Actor들은 메시지를 주고 받을 뿐이므로, 연산 단위들간의 가변 상태 공유를 허용하는 병행 모델들의 고질적인 문제점인 교착 상태(Deadlock), 경쟁 상태(Race condition) 등의 발생 가능성이 낮다.\n"},{"excerpt":"왜 마이그레이션을 해야 하는가? 현재 프로젝트에서 사용하고 있는 Scala 버전은 2.11.8이다. 시간이 흐르면서 지원이 점점 끊기는 구버전이 되고 있는 상황이고, 성능 및 편의가 개선된 상위 버전을 사용하는 것이 더 이로운 일이다. 하지만 바로 최신 버전으로 가기에는 부담이 되기 때문에 마이너 버전을 하나씩 올리는 방식으로 진행하였다. 목표 버전은 2…","fields":{"slug":"/scala-migration/"},"frontmatter":{"date":"July 15, 2023","title":"Scala Migration to 2.13","tags":["scala","migration"]},"rawMarkdownBody":"\n## 왜 마이그레이션을 해야 하는가?\n\n현재 프로젝트에서 사용하고 있는 Scala 버전은 2.11.8이다. 시간이 흐르면서 지원이 점점 끊기는 구버전이 되고 있는 상황이고, 성능 및 편의가 개선된 상위 버전을 사용하는 것이 더 이로운 일이다. 하지만 바로 최신 버전으로 가기에는 부담이 되기 때문에 마이너 버전을 하나씩 올리는 방식으로 진행하였다. 목표 버전은 2.13.x이다.\n\n## Scala 2.12.x\n\n```\n1. Maven 라이브러리 호환성\n2. Future 상속 시에 오버라이딩 구현\n```\n\n프로젝트에는 Scala 2.11.8이 적용되어 있었다. 1차적으로는 2.12.x로 마이그레이션 해야 했기 때문에 위의 두가지 목표를 가지고 진행했다. 2번의 경우에는 미리 다른 프로젝트에서 마이그레이션 작업을 진행하신 팀장님께서 공유해주신 사항을 참고하였다.\n\nScala 2.11.18로 설정하고 각 라이브러리 버전을 확인하여 맞는 버전으로 업그레이드 진행했다. 인텔리제이에서 빌드했을 때 별다른 오류 없이 성공했지만 Jenkins에서 빌드를 하니 실패했다. 원인은 Maven에서 Scala compile이 실패됐기 때문이었다.\n\n해당 문제에 대해 확인해보니 scala-maven-plugin의 버전 업그레이드가 필요했다. 4.2.4로 업그레이드 한 후 정상적으로 compile이 완료됐다. 로컬에서 간단한 테스트 후에 개발서버에 배포했지만 또 에러 로그를 발견했다. 에러 내용은 NullPointerException 이었다.\n\n해당 케이스 클래스의 타입은 Option이었기 때문에 NullPointerException이 발생하면 안됐지만, 디버깅 결과 Some(null) 형태로 들어가있는 데이터를 확인했다. 역직렬화가 되는 프로세스를 정확히 알지 못해 Hazelcast 호환성 문제일까 싶어서 버전을 변경한 후에 재확인을 했다. 하지만 결과는 그대로였다.\n\n검색과 테스트를 반복하다보니 Scala 2.12에서 직렬화 된 데이터를 2.13에서 역직렬화 하는 경우 Option 타입의 값을 정확히 객체화 시키지 못하고 Some(null)이 되는 경우가 있었다. 2.13에서 직렬화 한 후에 2.12에서 역직렬화 하는 경우에도 같은 증상을 확인했다.\n\n하위 호환성을 지원해야 올바르지만 해당 데이터는 캐시 데이터여서 리셋 후에 2.13 버전으로 직렬화 된 데이터를 쌓도록 했다. 개발 서버에 배포 후 정상 동작을 확인하고, Scala 버전을 최종적으로 2.12.15로 변경했다.\n\n## Scala 2.13.x\n\n곧바로 2.13으로 마이그레이션을 진행하기로 하였다. 2.12 마이그레이션과는 달리 코드를 변경해줘야 하는 부분이 많아서 작업량이 이전보다 많았다. Deprecated 예정인 API도 되도록 수정하는 방향으로 진행했다. Scala 버전은 다른 프로젝트에서 이미 적용된 2.13.8로 하였다.\n\n주요 변경 사항을 아래와 같다.\n\n```\n1. scala.collection.JavaConvnerters -> scala.jdk.CollectionConverters\n2. x.filterKeys(..).map(identity) -> x.view.filterKeys(..).toMap\n3. x.mapValues(..).map(identity) -> x.view.mapValues(..).toMap\n4. x.onSuccess -> x.foreach\n5. x.onFailure -> x.failed.foreach\n6. x.tryCompleteWith -> x.completeWith\n7. x.toIterator -> x.iterator\n8. StringBuilder.newBuilder -> new StringBuilder()\n```\n\n이 외에 import 시에 package 경로를 명확하게 정해줘야 한다.\n\nScala 2.13 버전부터 지원이 되지 않는 라이브러리가 있어서 교체가 필요했다.\n\n```\n1. scala-logging 추가\n2. scalamock-core, scalamock-scalatest-support 삭제\n3. scalamock 추가\n4. postgresql-async -> quill-async-postgresql 교체\n```\n\n수정 작업을 완료한 후에 maven에서 scala.compile이 정상적으로 되지 않아 scala-maven-plugin 버전을 최신 버전으로 올렸다. 이 후에는 빌드 및 실행 모두 정상적으로 되었고 개발 환경에 배포하면서 마이그레이션 작업을 마무리 했다.\n\n## 마무리\n\n버전 호환성만 확인하면 될거라고 생각했으나 몇가지 걸림돌이 숨겨져 있었다. 최신 버전이 아니고 마이너한 영역이라 레퍼런스의 도움을 받기도 쉽지 않았다. 문제를 예상하고 테스트 코드로 확인하는 과정을 필히 거치는 것이 좋을 것이라 생각하게 됐다.\n\n작업양이 많아서 모든 Deprecated를 걷어내지는 못했지만 추후 작업을 하면서 2.13 버전에 맞도록 계속 수정이 필요해보인다. 그리고 2.13에서 변화점이 많아서 유용한 API 등에 대해 학습이 필요하다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}