{"componentChunkName":"component---src-templates-post-jsx","path":"/message-driven-development/","result":{"data":{"site":{"siteMetadata":{"title":"nineruler's blog"}},"markdownRemark":{"id":"80af0ae2-754d-5f60-ad77-7f116cd162f4","excerpt":"Message Oriented Programming MOP: Message Oriented Programming 다양한 컴포넌트나 모듈이 서로 메시지를 주고받아 상호 작용하는 프로그래밍 패러다임.\n컴포넌트 간의 결합도를 낮추고 모듈화를 촉진하여 더 유연하고 확장 가능한 소프트웨어를 구축할 수 있다. 메시지 기반 또는 주도 프로그래밍이란 용어보다는 메시지 …","html":"<h2>Message Oriented Programming</h2>\n<p>MOP: Message Oriented Programming</p>\n<p>다양한 컴포넌트나 모듈이 서로 메시지를 주고받아 상호 작용하는 프로그래밍 패러다임.\n컴포넌트 간의 결합도를 낮추고 모듈화를 촉진하여 더 유연하고 확장 가능한 소프트웨어를 구축할 수 있다.</p>\n<p>메시지 기반 또는 주도 프로그래밍이란 용어보다는 메시지 지향 프로그래밍이라는 용어를 더 많이 사용하는 듯 하다.</p>\n<p>객체가 서로를 직접 호출하지 않고 메시지 버스를 통해 통신해야 한다는 특징을 가지고 있다.</p>\n<h2>주요 특징 및 개념</h2>\n<ol>\n<li>\n<p>메시지</p>\n<ul>\n<li>컴포넌트 간의 통신은 메시지를 통해 이루어진다.</li>\n<li>메시지는 sender가 보낸 메시지를 이벤트 버스를 통해 구독 중인 receiver로 전달된다.</li>\n</ul>\n</li>\n<li>\n<p>비동기 통신</p>\n<ul>\n<li>메시지 지향 프로그래밍은 비동기 통신이 일반적이다.</li>\n<li>sender가 즉시 결과를 기다리지 않고 작업을 계속할 수 있도록 한다.</li>\n<li>receiver는 메시지를 받아 작업을 처리하고 응답을 보낼 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>이벤트 주도</p>\n<ul>\n<li>메시지는 이벤트를 트리거하거나 처리하는 데 사용된다.</li>\n</ul>\n</li>\n<li>\n<p>모듈화와 결합도 감소</p>\n<ul>\n<li>각 컴포넌트가 독립적으로 작동하며, 메시지를 통해 상호 작용하므로 모듈화가 용이하다.</li>\n</ul>\n</li>\n<li>\n<p>분산 시스템</p>\n<ul>\n<li>분산 시스템에서 유용하게 활용된다.</li>\n<li>여러 컴포넌트나 서버가 네트워크를 통해 메시지를 주고받아 작업을 처리하고 결과를 공유할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<h2>장점</h2>\n<ol>\n<li>\n<p>발신자와 응답자 사이의 결합 제거</p>\n<ul>\n<li>객체가 서로를 직접 참조하지 않기 때문에 Code Refactoring 하는 경우에 작업이 원활하다.</li>\n</ul>\n</li>\n<li>\n<p>종속성 즉시 변경</p>\n<ul>\n<li>객체는 상황에 따라 메시지 구독하거나 취소할 수 있기 때문에 동작을 동적으로 변경할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>여러 구독자에게 발송</p>\n<ul>\n<li>여러 객체가 동일한 유형의 메시지를 동시에 수신 대기할 수 있다. 시스템의 여러 부분을 업데이트 해야하는 이벤트가 발생할 때 개별적으로 알리지 않아도 된다.</li>\n</ul>\n</li>\n</ol>\n<h2>단점</h2>\n<ol>\n<li>\n<p>메모리 및 처리 오버헤드</p>\n<ul>\n<li>메시지 전송에는 메시지 내 전달되는 데이터의 크기에 따라 메모리 및 처리 비용이 수반된다.</li>\n<li>메시지 통신하는 객체는 캡슐화된 상태를 공유해서는 안되기 때문에 메시지 데이터가 구독 객체에 의해 수정될 경우 데이터를 복사해서 사용해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>과도한 메시지 유형의 증가</p>\n<ul>\n<li>객체는 여러 가지 방법으로 서로 통신하기 때문에 필요한 메시지 유형의 수가 과도하게 증가할 수 있다.</li>\n<li>구현 방법에 관계없이 메시지 유형의 수가 많아질 수 있기 때문에 신중한 관리가 필요하다.</li>\n</ul>\n</li>\n<li>\n<p>흐름을 추론하기 어려움</p>\n<ul>\n<li>동적 특성으로 인해 정확한 흐름을 파악하는 것이 어려울 수 있다.</li>\n<li>그로 인해 디버깅 또한 까다로워진다.</li>\n</ul>\n</li>\n</ol>\n<h2>이벤트 주도 프로그래밍과의 차이</h2>\n<p>이벤트 주도 프로그래밍은 주로 이벤트를 중심으로 동작하며, 이벤트가 발생할 때 특정 동작을 수행한다. 이에 반해 메시지 지향 프로그래밍은 메시지를 주고받아 컴포넌트 간의 상호 작용을 관리하고 모듈화하는 데 중점을 둔다. 이벤트 주도 프로그래밍은 주로 사용자 입력이나 시스템 상태 변화에 응답하는 데 사용되고, 메시지 지향 프로그래밍은 컴포넌트 간의 통신과 모듈화에 사용된다.</p>\n<h2>Actor Model (행위자 모델)</h2>\n<p>Actor Model은 Actor를 병행 연산(Concurrent Computing)의 범용적 기본 단위로 삼는 모델이다.</p>\n<p>Actor Model에서 Actor들은 메시지를 주고 받을 뿐이므로, 연산 단위들간의 가변 상태 공유를 허용하는 병행 모델들의 고질적인 문제점인 교착 상태(Deadlock), 경쟁 상태(Race condition) 등의 발생 가능성이 낮다.</p>","frontmatter":{"title":"메시지 지향 프로그래밍","date":"July 22, 2023","update":"July 22, 2023","tags":["oop"],"series":null},"fields":{"slug":"/message-driven-development/","readingTime":{"minutes":5.705}}},"seriesList":{"edges":[{"node":{"id":"8d1f2fa8-c383-54c7-8643-fcb584053c40","fields":{"slug":"/scala-migration/"},"frontmatter":{"title":"Scala Migration to 2.13"}}},{"node":{"id":"80af0ae2-754d-5f60-ad77-7f116cd162f4","fields":{"slug":"/message-driven-development/"},"frontmatter":{"title":"메시지 지향 프로그래밍"}}},{"node":{"id":"521c99e5-b3b2-566f-b031-319718d3df3e","fields":{"slug":"/state-pattern/"},"frontmatter":{"title":"State Pattern을 선택하는 이유"}}},{"node":{"id":"1b40aa45-37fc-5313-af93-b830bd9ec5e6","fields":{"slug":"/policy-pattern/"},"frontmatter":{"title":"Policy Pattern"}}},{"node":{"id":"2a97d58f-706a-53ac-a1c6-5140580f5fe4","fields":{"slug":"/conceptual-design-modeling/"},"frontmatter":{"title":"Modeling에 대하여"}}},{"node":{"id":"ab6dddb6-d3cd-5006-8566-46b17d4730a5","fields":{"slug":"/solid/"},"frontmatter":{"title":"객체지향 디자인 원칙(SOLID)"}}}]},"previous":{"fields":{"slug":"/scala-migration/"},"frontmatter":{"title":"Scala Migration to 2.13"}},"next":{"fields":{"slug":"/state-pattern/"},"frontmatter":{"title":"State Pattern을 선택하는 이유"}}},"pageContext":{"id":"80af0ae2-754d-5f60-ad77-7f116cd162f4","series":null,"previousPostId":"8d1f2fa8-c383-54c7-8643-fcb584053c40","nextPostId":"521c99e5-b3b2-566f-b031-319718d3df3e"}},"staticQueryHashes":[],"slicesMap":{}}